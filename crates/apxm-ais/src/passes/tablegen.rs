//! TableGen Generator for Passes
//!
//! This module generates multiple files from Rust pass definitions:
//! - `Passes.generated.td` - MLIR TableGen pass definitions
//! - `PassDispatch.inc` - C API dispatch switch statement
//! - `PassDescriptors.inc` - Pass registry descriptors

use super::{PassCategory, PassSpec, get_ais_passes, get_all_passes};

// ============================================================================
// TableGen Generation (Passes.generated.td)
// ============================================================================

const PASSES_TD_HEADER: &str = r#"/**
 * @file  Passes.generated.td
 * @brief GENERATED from Rust - DO NOT EDIT MANUALLY
 *
 * This file is generated by apxm-ais/src/passes/tablegen.rs
 * To modify passes, edit crates/apxm-ais/src/passes/mod.rs
 */

#ifndef APXM_AIS_PASSES_GENERATED
#define APXM_AIS_PASSES_GENERATED

include "mlir/Pass/PassBase.td"

"#;

const PASSES_TD_FOOTER: &str = "\n#endif // APXM_AIS_PASSES_GENERATED\n";

/// Generate a TableGen pass definition.
fn generate_pass_def(pass: &PassSpec) -> String {
    let mut lines = Vec::new();

    // Pass definition
    lines.push(format!(
        "def {} : Pass<\"{}\", \"mlir::ModuleOp\"> {{",
        pass.class_name, pass.name
    ));

    // Summary
    lines.push(format!("  let summary = \"{}\";", pass.summary));

    // Description (multi-line)
    let escaped_desc = pass.description.replace('\n', "\n    ");
    lines.push(format!("  let description = [{{\n    {}\n  }}];", escaped_desc));

    // Constructor
    lines.push(format!("  let constructor = \"{}\";", pass.constructor));

    // Dependent dialects
    if !pass.dependent_dialects.is_empty() {
        let dialects: Vec<String> = pass
            .dependent_dialects
            .iter()
            .map(|d| format!("\"{}\"", d))
            .collect();
        lines.push(format!(
            "  let dependentDialects = [{}];",
            dialects.join(", ")
        ));
    }

    // Options
    if !pass.options.is_empty() {
        lines.push("  let options = [".to_string());
        for (i, opt) in pass.options.iter().enumerate() {
            let comma = if i < pass.options.len() - 1 { "," } else { "" };
            lines.push(format!(
                "    Option<\"{}\", \"{}\", \"{}\", /*default=*/\"{}\",\n           \"{}\">{}",
                opt.cpp_name, opt.name, opt.option_type, opt.default, opt.description, comma
            ));
        }
        lines.push("  ];".to_string());
    }

    lines.push("}".to_string());

    lines.join("\n")
}

/// Generate complete Passes.generated.td file content.
pub fn generate_passes_tablegen() -> String {
    let mut output = String::new();
    output.push_str(PASSES_TD_HEADER);

    // Section comments
    output.push_str("//===----------------------------------------------------------------------===//\n");
    output.push_str("// Domain-Specific Transform Passes\n");
    output.push_str("//===----------------------------------------------------------------------===//\n\n");

    let mut current_category: Option<PassCategory> = None;

    for pass in get_ais_passes() {
        // Skip built-in passes (they're not generated)
        if pass.is_builtin {
            continue;
        }

        // Add section header if category changed
        if current_category != Some(pass.category) {
            if current_category.is_some() {
                let section_name = match pass.category {
                    PassCategory::Transform => "Domain-Specific Transform Passes",
                    PassCategory::Optimization => "Optimization Passes",
                    PassCategory::Analysis => "Analysis/Warning Passes",
                    PassCategory::Lowering => "Conversion/Lowering Passes",
                };
                output.push_str("\n//===----------------------------------------------------------------------===//\n");
                output.push_str(&format!("// {}\n", section_name));
                output.push_str("//===----------------------------------------------------------------------===//\n\n");
            }
            current_category = Some(pass.category);
        }

        output.push_str(&generate_pass_def(pass));
        output.push_str("\n\n");
    }

    output.push_str(PASSES_TD_FOOTER);
    output
}

// ============================================================================
// Pass Dispatch Generation (PassDispatch.inc)
// ============================================================================

const DISPATCH_HEADER: &str = r#"/**
 * @file  PassDispatch.inc
 * @brief GENERATED from Rust - DO NOT EDIT MANUALLY
 *
 * This file is included by PassManager.cpp to dispatch pass creation.
 * Generated by apxm-ais/src/passes/tablegen.rs
 *
 * Usage in PassManager.cpp:
 *   llvm::StringRef name(pass_name);
 *   #include "PassDispatch.inc"
 *   return false;  // Unknown pass
 */

// Generated pass dispatch - match pass_name and add to pm->pass_manager
"#;

/// Generate PassDispatch.inc content.
///
/// This generates a series of if-else statements that map pass names
/// to their constructors. Uses llvm::StringRef for string comparison.
pub fn generate_pass_dispatch() -> String {
    let mut output = String::new();
    output.push_str(DISPATCH_HEADER);

    let passes: Vec<&PassSpec> = get_all_passes().collect();

    for (i, pass) in passes.iter().enumerate() {
        let if_keyword = if i == 0 { "if" } else { "} else if" };

        output.push_str(&format!(
            "{} (name == \"{}\") {{\n  pm->pass_manager->addPass({});\n  return true;\n",
            if_keyword, pass.name, pass.constructor
        ));
    }

    output.push_str("}\n");
    output
}

// ============================================================================
// Pass Descriptors Generation (PassDescriptors.inc)
// ============================================================================

const DESCRIPTORS_HEADER: &str = r#"/**
 * @file  PassDescriptors.inc
 * @brief GENERATED from Rust - DO NOT EDIT MANUALLY
 *
 * This file is included by PassRegistry.cpp to provide pass metadata.
 * Generated by apxm-ais/src/passes/tablegen.rs
 */

// Pass descriptors array entries
"#;

/// Generate PassDescriptors.inc content.
pub fn generate_pass_descriptors() -> String {
    let mut output = String::new();
    output.push_str(DESCRIPTORS_HEADER);

    for pass in get_all_passes() {
        output.push_str(&format!(
            "{{\"{}\", \"{}\", {}}},\n",
            pass.name,
            pass.summary,
            pass.category.to_c_enum()
        ));
    }

    output
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_passes_tablegen() {
        let output = generate_passes_tablegen();

        // Check header
        assert!(output.contains("#ifndef APXM_AIS_PASSES_GENERATED"));
        assert!(output.contains("GENERATED from Rust"));

        // Check AIS passes are present
        assert!(output.contains("def NormalizeAgentGraph"));
        assert!(output.contains("def FuseAskOps"));
        assert!(output.contains("def AISToAsyncPass"));

        // Check built-in passes are NOT present (they're not generated)
        assert!(!output.contains("def Canonicalizer"));

        // Check footer
        assert!(output.contains("#endif // APXM_AIS_PASSES_GENERATED"));
    }

    #[test]
    fn test_generate_pass_dispatch() {
        let output = generate_pass_dispatch();

        // Check all passes are present
        assert!(output.contains("\"normalize\""));
        assert!(output.contains("\"fuse-ask-ops\""));
        assert!(output.contains("\"canonicalizer\""));
        assert!(output.contains("\"cse\""));

        // Check constructors
        assert!(output.contains("createNormalizeAgentGraphPass"));
        assert!(output.contains("createFuseAskOpsPass"));
    }

    #[test]
    fn test_generate_pass_descriptors() {
        let output = generate_pass_descriptors();

        // Check all passes are present
        assert!(output.contains("\"normalize\""));
        assert!(output.contains("\"fuse-ask-ops\""));
        assert!(output.contains("\"canonicalizer\""));

        // Check categories
        assert!(output.contains("APXM_PASS_TRANSFORM"));
        assert!(output.contains("APXM_PASS_OPTIMIZATION"));
        assert!(output.contains("APXM_PASS_LOWERING"));
    }

    #[test]
    fn test_scheduling_options_in_tablegen() {
        let output = generate_passes_tablegen();

        // Check scheduling pass has options
        assert!(output.contains("parallelThreshold"));
        assert!(output.contains("parallel-threshold"));
        assert!(output.contains("baseCost"));
    }

    #[test]
    fn test_dependent_dialects_in_tablegen() {
        let output = generate_passes_tablegen();

        // Check lower-to-async has dependent dialects
        assert!(output.contains("async::AsyncDialect"));
        assert!(output.contains("func::FuncDialect"));
    }
}
